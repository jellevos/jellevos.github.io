<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Depth-aware arithmetization | Jelle Vos</title> <meta name="author" content="Jelle Vos"/> <meta name="description" content="Generating arithmetic circuits over finite fields that trade off multiplicative size and depth"/> <meta name="keywords" content="jelle vos, tu delft, homomorphic encryption, scicrypt, phd, private set operations, secure computation, lattice, cryptography"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ“</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jelle-vos.nl/projects/depth_aware_arithmetization/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">JelleÂ </span>Vos</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Depth-aware arithmetization</h1> <p class="post-description">Generating arithmetic circuits over finite fields that trade off multiplicative size and depth</p> </header> <article> <p>Check out <a href="https://eprint.iacr.org/2024/1200" target="_blank" rel="noopener noreferrer"> our eprint article!</a></p> <p>Homomorphic encryption schemes like BGV allow users to perform computations on data under encryption. Specifically, they can perform a number of additions and multiplications. There is a limit to the number of operations, induced by the noise that is added to these ciphertexts (for security purposes), and which grows after each addition or multiplication. We can increase the limit by choosing larger parameters, but these will slow down the computations.</p> <p>The computation model described above is that of arithmetic circuits, and the process of turning a function into arithmetic is called <i>arithmetization</i>. If the plaintext space is a finite field (e.g. if the plaintext modulus \(p\) is a prime), then any function can be turned into additions and multiplications. Doing so by hand, however, is a complex and time-consuming job. To prevent this, much research has been done to achieve efficient arithmetic circuits for primitives such as equality checks, comparisons, and OR operations. However, these circuits have typically not been generated with noise in mind.</p> <p>The noise in an arithmetic circuit is mainly determined by its multiplicative depth: the largest number of multiplications in any path through the circuit. On the other hand, the computational cost is typically decided by the multiplicative size: the total number of multiplications in the circuit. However, the concrete cost of a multiplication is bound to the multiplicative depth. <b>Note that we only count multiplications between two variables; multiplications with constants are cheap to perform!</b> In this post, we look at three methods for finding circuits that (near-)optimally trade off multiplicative size and depth.</p> <h2>Exponentiation &amp; equality</h2> <p>Exponentiation circuits have been studied before for improving performance of elliptic curve multiplication, the RSA cryptosystem, and the AES cryptosystem. However, these works typically do not study the tradeoff between size and depth. One work that does consider this is that by <a href="https://arxiv.org/abs/2306.15002" target="_blank" rel="noopener noreferrer">Abbas &amp; Gustafsson</a>, which uses integer linear programming to generate multiplication circuits with a maximum depth to compute a specific power. However, this approach is quite slow. We show how to reformulate this as a MaxSAT formulation and show that, by incorporating some additional bounds, we can compute the optimal Pareto front for powers lower than 100 in a few seconds.</p> <p>A MaxSAT formulation is a SAT formulation with hard and soft clauses. Hard clauses must always be satisfied, but soft clauses may be dropped at the cost of a weight value. A MaxSAT solver then finds a solution to the clauses that incurs the lowest cost incurred by relaxing soft clauses. It does so by making repeated calls to an underlying SAT solver. Some solvers require the weight of soft clauses to be fixed, while others allow them to be any value. Varying the weights allows us to model that squaring is a cheaper operation than multiplication. In our experiments, we use the RC2 MaxSAT solver.</p> <p>Our MaxSAT formulation computes some target exponent \(t\). It uses variables \(x_i\) for \(i = 1, \dots, t\) to denote whether exponent \(i\) has been reached in the circuit. Multiplications perform transitions between two inputs \(x_i\) and \(x_j\), and one output exponent \(x_{i+j}\). We use variables \(y_{i,j}\) to denote whether the circuit has performed a multiplication between \(x_i\) and \(x_j\). The hard clauses (presented in conjunctive normal form) are as follows:</p> \[\bigvee_{i+j=k} y_{i,j} \vee \neg x_k,\] \[\neg y_{i,j} \vee x_i,\] \[\neg y_{i,j} \vee x_j,\] <p>We consider \(i, j, k \in \{1, \dots, t\}\). We also enforce \(x_t\). These clauses ensure that a multiplication can only be performed when its inputs have previously been computed and that we must exponentiate to \(t\). The soft clauses are simply \(y_{i,j}\). We can use a variable weight to denote that \(y_{i,i}\) is cheaper to compute than \(y_{i,j}\) for \(i \ne j\).</p> <p>Abbas &amp; Gustafsson already add a powerful bound to model that \(x_k\) can only be true if the following holds: \(x_{\lceil k/2 \rceil} \vee \dots \vee x_{k-1}\). We also add the bounds by <a href="https://www.sciencedirect.com/science/article/pii/S0012365X20303861" target="_blank" rel="noopener noreferrer">Thurber &amp; Clift</a>, which provide a speedup for larger values of \(t\). Next to that, since we compute the entire Pareto front, we can use knowledge of previous computations to compute a lower and upper bound on the cost of the formulation.</p> <p>Now, to take depth into account, we use the same technique as Abbas &amp; Gustafsson, but since we are working with Boolean variables we cannot perform addition as easily. We choose to model the depth of \(x_k\) using several variables \(d_{k,d'}\) for \(d' \in \{1, \dots, \text{max depth} \}\). We change the formulation accordingly, by adding several hard clauses.</p> <p>The resulting formulation can be used to compute optimal Pareto fronts for exponentiations in \(\mathbb{Z}\). To take the modulus \(p\) into account, we can sequentially compute optimal solutions for a target \(t + pi\), until we are certain that no better circuit can be achieved. We use this technique to compute the optimal Pareto front for all exponents in \(\mathbb{Z}_p\) in just 4 seconds on a laptop.</p> <p>Why go through so much effort to find optimal exponentiation circuits? The answer is that they are a crucial building block of many common primitives, so any optimizations here have a large impact on the final performance. For example, to check whether an input \(z \in \mathbb{Z}_p\) is non-zero, we can compute \(z^{p-1}\). This fact can then immediately be used to implement an equality check \(a = b\) as \(1 - (a - b)^{p-1}\).</p> <h2>Univariate polynomial evaluation &amp; comparisons</h2> <p>Arithmetic circuits compute multivariate polynomials. While it is easy to compute the multivariate polynomial that is computed by a circuit, the opposite is not true: it is extremely hard to find efficient circuits for arbitrary polynomials. Still, some common primitives do not have such natural formulations as the equality check shown above, so polynomial evaluation might be our best bet.</p> <p>While multivariate polynomials are very hard to arithmetize efficiently, univariate polynomials are somewhat easier to study. Much work has gone into this area. One of the most fundamental results is by <a href="https://epubs.siam.org/doi/abs/10.1137/0202007?casa_token=jW3FzEnzE4MAAAAA:vHWKzedWp3uVmgJcU3dFkprLtSYpwuriISDVmLS9BQa962g3S33GEf0TkUbdMZ1P9wLEJFA7UtWH" target="_blank" rel="noopener noreferrer">Paterson and Stockmeyer</a>, who provide two algorithms for computing univariate polynomials of degree \(d\). The first method is a baby-step giant-step approach, which takes roughly \(2\sqrt{d}\) multiplications. The second method alters the first method to achieve roughly \(\sqrt{2d}\) multiplications. They show that the multiplicative size of these circuits is asymptotically optimal.</p> <p>These theoretical results are already of great practical value. However, Paterson &amp; Stockmeyer only analyzed the multiplicative size of these circuits; not their depth. In fact, both methods have some parameter \(k\) that must be set beforehand, and in choosing its value, the authors choose it to be optimal when it comes to the size of the circuit. We show that, by varying \(k\), we can very efficiently produce a large amount of polynomial evaluation circuits of varying depth. While this does not produce provably optimal circuits, the circuits are close to optimal for small values of \(d\).</p> <p>In previous work, <a href="https://hal.science/hal-03506798/" target="_blank" rel="noopener noreferrer">Iliashenko &amp; Zucca</a> show how to efficiently express comparisons such as \(a &lt; b\) as a univariate polynomial, specifically when \(a, b &lt; \frac{p-1}{2}\). They use properties from the second method by Paterson &amp; Stockmeyer to reduce the multiplicative size of the circuit. To amend the first method of Paterson &amp; Stockmeyer to this same trick, we use the MaxSAT formulation above. Finally, we show that one can lift the restriction that \(a, b &lt; \frac{p-1}{2}\) by computing three polynomial evaluations.</p> <h2>AND and OR operations over multiple variables</h2> <p>In the above two examples (equality checks and comparisons), the circuit does not change if one of the inputs has a lower depth than the other. This is because the first step in computing them requires subtracting them. The multiplicative depth after subtraction is the maximum of the two. AND and OR circuits, on the other hand, change significantly depending on the depths of the inputs. We assume that the inputs are in \(\{ 0, 1\}\).</p> <p>The most common way to arithmetize an AND operation is to use a simple product: \(x_1 \wedge x_2 \wedge \dots \wedge x_k = x_1 x_2 \dots x_k\)</p> <p>The result is a circuit of depth \(\lceil \log_2 \sum_{i=1}^k \operatorname{depth}(x_i) \rceil\). If the variables are completely independent (i.e. there are no common subexpressions), then the size of the resulting circuit is \(k-1 + \sum_{i=1}^k \operatorname{size}(x_i)\). This is not the only efficient arithmetization, however. Consider the following arithmetization of an OR operation with $k \le p-1$:</p> \[x_1 \vee x_2 \vee \dots \vee x_k = (x_1 + x_2 + \dots + x_k)^{p-1}\] <p>This circuit adds up the inputs so they do not overflow the modulus, and then checks if the result is non-zero. This circuitâ€™s depth is \(D + \max_{i=1,\dots,k} \operatorname{depth}(x_i)\), where \(D\) is the depth of the exponentiation circuit (see first section). The size is \(S + \sum_{i=1}^k \operatorname{size}(x_i)\), where \(S\) is the size of the exponentiation circuit.</p> <p>Arithmetizations for AND operations can easily be translated to OR operations (and the other way around) using DeMorganâ€™s law: \(x_1 \vee x_2 \vee \dots \vee x_k = \overline{\overline{x_1} \wedge \overline{x_2} \wedge \dots \wedge \overline{x_k}}\)</p> <p>These arithmetization can be combined into hybrid circuits that find a tradeoff between depth and size. The smallest practical example of this happens when \(k = 7\) and \(p = 5\). The circuit generated using the first arithmetization has size 6 and depth 3 (circuit A). However, when we consider the hybrid solution, we can generate two better circuits. The first has depth 4 and size 4 (circuit B), the second has depth 3 and size 5 (circuit C).</p> <p>Given these two arithmetic circuits, we do not know which one is more performant in practice. We use HElib and fhegen to gather some preliminary results. For fhegen we used the OpenFHE model as it does not include rotations (we do not consider ciphertext packing). The results, when computed on an M1 CPU, are as follows: Circuit A takes 36.2 ms, circuit B takes 41.3 ms, circuit C takes 22.8 ms. Circuits A and C had a lower depth, which allowed the use of a smaller ring dimension. Moreover, circuit C had a lower cost than circuit A as it has fewer multiplications (and two multiplications are squarings).</p> <s>We are currently integrating these algorithms in the <a href="https://github.com/jellevos/oraqle" target="_blank" rel="noopener noreferrer">oraqle compiler</a> for secure computation, which we plan to release in April.</s> <p>The oraqle compiler is available! Some of the early features of the compiler are described in <a href="https://eprint.iacr.org/2024/1409" target="_blank" rel="noopener noreferrer"> the following eprint article</a>.</p> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> Â© Copyright 2025 Jelle Vos. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with the <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Last updated: August 31, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>