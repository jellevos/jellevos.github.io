<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Arithmetization in the polynomial ring | Jelle Vos</title> <meta name="author" content="Jelle Vos"/> <meta name="description" content="Generating arithmetic circuits that exploit batching and automorphisms"/> <meta name="keywords" content="jelle vos, tu delft, homomorphic encryption, scicrypt, phd, private set operations, secure computation, lattice, cryptography"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ“</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jelle-vos.nl/projects/arithmetization_in_zpx/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">JelleÂ </span>Vos</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Arithmetization in the polynomial ring</h1> <p class="post-description">Generating arithmetic circuits that exploit batching and automorphisms</p> </header> <article> <p><a href="/projects/depth_aware_arithmetization">In a previous blog post</a>, we presented methods for performing depth aware arithmetization in prime fields \(\mathbb{F}_p\). In other words, we showed how to realize high-level circuits in \(\mathbb{F}_p\), which only defines additions and multiplications. What made these methods <i>depth-aware</i>, is that we generated circuits that achieve a trade off between their multiplicative depth (the largest number of multiplications on any path through the circuit) and the total number of multiplications. These methods allowed us to generate more efficient circuits for e.g. comparisons (\(a &lt; b\)) than previous works. However, these methods leave several things to be desired: they do not consider batching and automorphisms. In this blog post, we will show how to consider automorphisms by extending beyond prime fields, and how to further optimize circuits in the context of homomorphic encryption by exploiting batching in the polynomial ring.</p> <h2 data-processed="0">Arithmetization in \(\mathbb{F}_{p^d}\): Exploiting automorphisms</h2> <p>In the finite fields \(\mathbb{F}<em>p\) that we previously considered, all the useful operations are described by additions and multiplications. In those prime fields, the only automorphism is the identity map. However, when we consider non-prime fields \(\mathbb{F}</em>{p^d}\), there are several useful automorphisms of the form \(x \mapsto x^{p^k}\), where \(0 &lt; k &lt; d\). When \(k=1\), we call this the Frobenius automorphism. As such, where arithmetic circuits over \(\mathbb{F}_p\) were only comprised of additions and multiplications, we now consider additions, multiplications, and automorphisms.</p> <p>While these automorphisms may not seem all that useful by themselves, they can be used to efficiently compute the field norm and trace. These operations, in turn, can be used to (more) efficiently evaluate polynomials, as shown by Hiroki Okada, Rachel Player, and Simon Pohmann in <a href="https://eprint.iacr.org/2023/1304" target="_blank" rel="noopener noreferrer">this article</a>, or to speed up matrix multiplications, as shown by Jai Hyun Park in <a href="https://eprint.iacr.org/2025/448" target="_blank" rel="noopener noreferrer">this other article</a>. In this blog post, we will focus on univariate polynomial evaluation, which allows us to compute comparison operations even more efficiently than before!</p> <p>So how does this work? The trick is that there is a relation between the minimal polynomial of an element \(\alpha \in \mathbb{F}_{p^d}\) and its field norm: \(\operatorname{Norm}(\alpha - x) = \operatorname{MiPo}(\alpha)(x),\) where \(\operatorname{MiPo}(\alpha)\) is the monic (univariate) polynomial of the lowest degree that maps \(\alpha\) to zero. Because no lower degree polynomials exist that also map \(\alpha\) to zero, the minimal polynomial is irreducible. This relation allows us to evaluate any irreducible polynomial over \(\mathbb{F}_p\) by finding a suitable \(\alpha\) and computing the field norm of \(\alpha - x\). Note that the polynomialâ€™s degree must be lower than \(D\)!</p> <p>So how do we find such a suitable \(\alpha \in \mathbb{F}<em>{p^d}\)? To evaluate an irreducible monic polynomial with coefficients in \( \mathbb{F}_p \), we want to find its root in the polynomial ring \(\mathbb{F}</em>{p^d}[X]\). Our current approach is to factor the polynomial in this polynomial ring. For larger polynomials, this can be a costly process, but it only has to be computed once (\(\alpha \) does not depend on the inputs of the polynomial evaluation).</p> <p>The reason that this approach leads to more efficient evaluations, is that whereas previous methods required \( O(\sqrt{D}) \) multiplications to compute a degree-\(D\) polynomial, the norm can be computed in only \( 2 \log_2(D) \) multiplications and automorphisms. As such, it leads to significantly more efficient circuits when evaluating large polynomials.</p> <p>How can we evaluate reducible polynomials? Just like Hiroki Okada, Rachel Player, and Simon Pohmann, we add an easily computable term to the polynomial that makes it irreducible, and we remove this term after the polynomial evaluation. In our experiments, it has always been sufficient to add a simple constant to the polynomial.</p> <h2 data-processed="0">Arithmetization in \( \mathbb{Z}_p/(X^N + 1) \): Exploiting batching</h2> <p><i>Note: we only consider \(N\) that are powers of two!</i></p> <p>Batching (or the SIMD encoding) is a ubiquitous tool in fully homomorphic encryption schemes such as BFV and BGV because it allows one to pack multiple elements into one ciphertext and perform the same additions and multiplications on all of them. The oraqle compiler so far has not considered batching at all, so the only way to exploit batching was to evaluate the circuit many times in parallel. However, batching can also be used when we only want to compute one evaluation of an arithmetic circuit.</p> <p>Batching relies on the fact that the quotient polynomial \(X^N + 1\) factors into multiple smaller equal-degree irreducible polynomials modulo \(p\). These sub-polynomials allow us to encode elements into separate slots, which are isomorphic to the finite fields we arithmetized over in the previous section. Previous work has shown how to achieve a grid layout for these slots, allowing rotating dimensions of the grid using automorphisms.</p> <p>In the compiler, we introduce new nodes in the style of functional programming. For now, we are implementing maps, reduces, and splicing operations. When the sequences they work on are small enough, we can map them onto the grid layout mentioned above. The compiler tries many possible assignments to achieve a trade off between multiplications and automorphism operations (for rotations).</p> <h2 data-processed="0">Polynomial evaluation in $\mathbb{Z}_p/(X^N + 1)$</h2> <p>In our <a href="https://eprint.iacr.org/2024/1200" target="_blank" rel="noopener noreferrer">article on depth-aware arithmetization</a>, we proposed a simple divide-and-conquer technique for evaluating large-degree polynomials that often produces lower-depth solutions than previous work such as the baby-step giant-step method and the Paterson-Stockmeyer method. We can also use this technique to evaluate polynomials of larger degrees by splitting it up into multiple smaller univariate polynomial evaluations. This, in turn, allows us to use the efficient automorphism-based approach described above. We take the following steps:</p> <ul> <li>We split the large-degree polynomial up into evaluations of degree-\(D\) polynomials</li> <li>We use the Map node to evaluate all degree-\(D\) polynomials in parallel using automorphisms</li> <li>We use the Reduce node to combine the results, multiplying the appropriate terms with powers of \(x\)</li> </ul> <p>By using the functional programming nodes defined above, the compiler can find the best way to pack these evaluations into multiple ciphertexts.</p> <p>We are still implementing these techniques in the <a href="https://github.com/jellevos/oraqle" target="_blank" rel="noopener noreferrer">oraqle compiler compiler</a>, and we expect to take a month or two to release the next version. Behind the scenes, there a lot of changes! For example, we now require supporting multiple plaintext algebras and the functional programming nodes add a completely new optimization step. We are also still experimenting with some heuristics for merging multiple functional programming nodes automatically.</p> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> Â© Copyright 2025 Jelle Vos. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with the <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. Last updated: August 31, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>